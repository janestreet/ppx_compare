open Ppx_compare_lib.Builtin

type t =
  { x : int [@compare.ignore]
  ; y : int
  }
[@@deriving equal]

[%%expect
  {|
Line _, characters _-_:
Error: Cannot use [@compare.ignore] with [@@deriving equal]
|}]

type t =
  { x : int [@equal.ignore]
  ; y : int
  }
[@@deriving compare, equal]

[%%expect
  {|
Line _, characters _-_:
Error: Cannot use [@equal.ignore] with [@@deriving compare].
|}]

(* The following ones are OK: *)

type t =
  { x : int [@compare.ignore] [@equal.ignore]
  ; y : int
  }
[@@deriving compare, equal]

[%%expect {| |}]

type t =
  { x : int [@ignore]
  ; y : int
  }
[@@deriving compare, equal]

[%%expect {| |}]

let [%compare: M.N(K).t] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Invalid identifier M.N(K).t for converter in pattern position. Only
       simple identifiers (like t or string) or applications of functors with
       simple identifiers (like M(K).t) are supported.
|}]

let [%compare: unit * unit] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Only type variables and constructors are allowed here (e.g. ['a], [t],
       ['a t], or [M(X).t]).
|}]

(* Use [compare ~portable] in structure context to get a better error message. *)

module Non_portable : sig
  type t [@@deriving compare]
end @ nonportable =
  Int

type t =
  { portable : int
  ; non_portable : Non_portable.t
  }
[@@deriving compare ~portable]

[%%expect
  {|
Line _, characters _-_:
Error: The value Non_portable.compare is nonportable, so cannot be used inside a function that is portable.
|}]
